package backup

import (
	"fmt"
	"strings"
	"sync"
	"time"

	"bcrdf/internal/compression"
	"bcrdf/internal/crypto"
	"bcrdf/internal/index"
	"bcrdf/pkg/s3"
	"bcrdf/pkg/utils"
)

// Manager g√®re les op√©rations de sauvegarde
type Manager struct {
	configFile string
	config     *utils.Config
	indexMgr   *index.Manager
	encryptor  *crypto.EncryptorV2
	compressor *compression.Compressor
	s3Client   *s3.Client
}

// NewManager cr√©e un nouveau gestionnaire de sauvegarde
func NewManager(configFile string) *Manager {
	return &Manager{
		configFile: configFile,
	}
}

// CreateBackup effectue une sauvegarde compl√®te
func (m *Manager) CreateBackup(sourcePath, backupName string) error {
	utils.Info("üöÄ D√©but de la sauvegarde: %s", backupName)
	startTime := time.Now()

	// Charger la configuration
	config, err := utils.LoadConfig(m.configFile)
	if err != nil {
		return fmt.Errorf("erreur lors du chargement de la configuration: %w", err)
	}
	m.config = config

	// Initialiser les composants
	if err := m.initializeComponents(); err != nil {
		return fmt.Errorf("erreur lors de l'initialisation: %w", err)
	}

	// V√©rifier que le chemin source existe
	if !utils.FileExists(sourcePath) {
		return fmt.Errorf("le chemin source n'existe pas: %s", sourcePath)
	}

	// Cr√©er l'ID de sauvegarde
	backupID := fmt.Sprintf("%s-%s", backupName, time.Now().Format("20060102-150405"))

	// Cr√©er l'index de la sauvegarde actuelle
	currentIndex, err := m.indexMgr.CreateIndex(sourcePath, backupID)
	if err != nil {
		return fmt.Errorf("erreur lors de la cr√©ation de l'index: %w", err)
	}

	// Chercher la sauvegarde pr√©c√©dente pour comparaison
	previousIndex, err := m.findPreviousBackup()
	if err != nil {
		utils.Warn("Aucune sauvegarde pr√©c√©dente trouv√©e, sauvegarde compl√®te")
	}

	// Comparer les index pour d√©terminer les changements
	var diff *index.IndexDiff
	if previousIndex != nil {
		diff, err = m.indexMgr.CompareIndexes(currentIndex, previousIndex)
		if err != nil {
			return fmt.Errorf("erreur lors de la comparaison des index: %w", err)
		}
	} else {
		// Premi√®re sauvegarde, tous les fichiers sont nouveaux
		diff = &index.IndexDiff{
			Added:    currentIndex.Files,
			Modified: []index.FileEntry{},
			Deleted:  []index.FileEntry{},
		}
	}

	// Sauvegarder les fichiers modifi√©s/ajout√©s
	if err := m.backupFiles(diff.Added, diff.Modified, backupID); err != nil {
		return fmt.Errorf("erreur lors de la sauvegarde des fichiers: %w", err)
	}

	// Mettre √† jour les m√©tadonn√©es de l'index
	currentIndex.CompressedSize = m.calculateCompressedSize(diff.Added, diff.Modified)
	currentIndex.EncryptedSize = m.calculateEncryptedSize(diff.Added, diff.Modified)

	// Sauvegarder l'index
	if err := m.indexMgr.SaveIndex(currentIndex); err != nil {
		return fmt.Errorf("erreur lors de la sauvegarde de l'index: %w", err)
	}

	duration := time.Since(startTime)
	utils.Info("‚úÖ Sauvegarde termin√©e en %v", duration)
	utils.Info("üìä Statistiques: %d fichiers ajout√©s, %d modifi√©s, %d supprim√©s",
		len(diff.Added), len(diff.Modified), len(diff.Deleted))

	return nil
}

// DeleteBackup supprime une sauvegarde
func (m *Manager) DeleteBackup(backupID string) error {
	utils.Info("üóëÔ∏è Suppression de la sauvegarde: %s", backupID)

	// Initialiser les composants si n√©cessaire
	if err := m.initializeComponents(); err != nil {
		return fmt.Errorf("erreur lors de l'initialisation des composants: %w", err)
	}

	// Charger l'index de la sauvegarde
	backupIndex, err := m.indexMgr.LoadIndex(backupID)
	if err != nil {
		return fmt.Errorf("erreur lors du chargement de l'index: %w", err)
	}

	// Supprimer les fichiers de donn√©es
	if err := m.deleteBackupFiles(backupIndex); err != nil {
		return fmt.Errorf("erreur lors de la suppression des fichiers: %w", err)
	}

	// Supprimer l'index
	if err := m.deleteBackupIndex(backupID); err != nil {
		return fmt.Errorf("erreur lors de la suppression de l'index: %w", err)
	}

	utils.Info("‚úÖ Sauvegarde supprim√©e: %s", backupID)
	return nil
}

// initializeComponents initialise tous les composants n√©cessaires
func (m *Manager) initializeComponents() error {
	// Charger la configuration si n√©cessaire
	if m.config == nil {
		config, err := utils.LoadConfig(m.configFile)
		if err != nil {
			return fmt.Errorf("erreur lors du chargement de la configuration: %w", err)
		}
		m.config = config
	}

	// Initialiser le gestionnaire d'index
	m.indexMgr = index.NewManager(m.configFile)

	// Initialiser le chiffreur avec l'algorithme configur√©
	algorithm := crypto.EncryptionAlgorithm(m.config.Backup.EncryptionAlgo)
	if algorithm == "" {
		algorithm = crypto.AES256GCM // Valeur par d√©faut
	}

	encryptor, err := crypto.NewEncryptorV2(m.config.Backup.EncryptionKey, algorithm)
	if err != nil {
		return fmt.Errorf("erreur lors de l'initialisation du chiffreur: %w", err)
	}
	m.encryptor = encryptor

	// Initialiser le compresseur
	compressor, err := compression.NewCompressor(m.config.Backup.CompressionLevel)
	if err != nil {
		return fmt.Errorf("erreur lors de l'initialisation du compresseur: %w", err)
	}
	m.compressor = compressor

	// Initialiser le client S3
	s3Client, err := s3.NewClient(
		m.config.Storage.AccessKey,
		m.config.Storage.SecretKey,
		m.config.Storage.Region,
		m.config.Storage.Endpoint,
		m.config.Storage.Bucket,
	)
	if err != nil {
		return fmt.Errorf("erreur lors de l'initialisation du client S3: %w", err)
	}
	m.s3Client = s3Client

	return nil
}

// findPreviousBackup trouve la sauvegarde pr√©c√©dente
func (m *Manager) findPreviousBackup() (*index.BackupIndex, error) {
	// Charger la configuration si n√©cessaire
	if m.config == nil {
		config, err := utils.LoadConfig(m.configFile)
		if err != nil {
			return nil, err
		}
		m.config = config
	}

	// Initialiser le client S3 si n√©cessaire
	if m.s3Client == nil {
		s3Client, err := s3.NewClient(
			m.config.Storage.AccessKey,
			m.config.Storage.SecretKey,
			m.config.Storage.Region,
			m.config.Storage.Endpoint,
			m.config.Storage.Bucket,
		)
		if err != nil {
			return nil, fmt.Errorf("erreur lors de l'initialisation du client S3: %w", err)
		}
		m.s3Client = s3Client
	}

	// Lister les index disponibles
	keys, err := m.s3Client.ListObjects("indexes/")
	if err != nil {
		utils.Warn("Impossible de lister les index: %v", err)
		return nil, nil
	}

	if len(keys) == 0 {
		utils.Debug("Aucun index trouv√©, premi√®re sauvegarde")
		return nil, nil
	}

	// Trouver l'index le plus r√©cent
	var latestKey string
	var latestTime time.Time

	for _, key := range keys {
		if strings.HasSuffix(key, ".json") {
			// Extraire l'ID de sauvegarde du nom de fichier
			backupID := strings.TrimSuffix(strings.TrimPrefix(key, "indexes/"), ".json")

			// Charger l'index pour obtenir la date de cr√©ation
			index, err := m.indexMgr.LoadIndex(backupID)
			if err != nil {
				utils.Warn("Impossible de charger l'index %s: %v", backupID, err)
				continue
			}

			// V√©rifier si cet index est plus r√©cent
			if index.CreatedAt.After(latestTime) {
				latestTime = index.CreatedAt
				latestKey = key
			}
		}
	}

	if latestKey == "" {
		utils.Debug("Aucun index valide trouv√©")
		return nil, nil
	}

	// Extraire l'ID de la sauvegarde la plus r√©cente
	backupID := strings.TrimSuffix(strings.TrimPrefix(latestKey, "indexes/"), ".json")

	utils.Info("Sauvegarde pr√©c√©dente trouv√©e: %s (cr√©√©e le %s)",
		backupID, latestTime.Format("2006-01-02 15:04:05"))

	// Charger l'index de la sauvegarde pr√©c√©dente
	previousIndex, err := m.indexMgr.LoadIndex(backupID)
	if err != nil {
		utils.Warn("Impossible de charger l'index de la sauvegarde pr√©c√©dente: %v", err)
		return nil, nil
	}

	return previousIndex, nil
}

// backupFiles sauvegarde les fichiers sp√©cifi√©s
func (m *Manager) backupFiles(added, modified []index.FileEntry, backupID string) error {
	allFiles := append(added, modified...)

	if len(allFiles) == 0 {
		utils.Info("Aucun fichier √† sauvegarder")
		return nil
	}

	utils.Info("Sauvegarde de %d fichiers", len(allFiles))

	// Cr√©er un pool de workers pour le traitement parall√®le
	semaphore := make(chan struct{}, m.config.Backup.MaxWorkers)
	var wg sync.WaitGroup
	errors := make(chan error, len(allFiles))

	for _, file := range allFiles {
		wg.Add(1)
		go func(f index.FileEntry) {
			defer wg.Done()
			semaphore <- struct{}{}        // Acqu√©rir un slot
			defer func() { <-semaphore }() // Lib√©rer le slot

			if err := m.backupSingleFile(f, backupID); err != nil {
				errors <- fmt.Errorf("erreur lors de la sauvegarde de %s: %w", f.Path, err)
			}
		}(file)
	}

	wg.Wait()
	close(errors)

	// V√©rifier s'il y a eu des erreurs
	for err := range errors {
		utils.Error("%v", err)
	}

	return nil
}

// backupSingleFile sauvegarde un seul fichier
func (m *Manager) backupSingleFile(file index.FileEntry, backupID string) error {
	if file.IsDirectory {
		return nil // Ignorer les r√©pertoires
	}

	utils.Debug("Sauvegarde du fichier: %s", file.Path)

	// Lire le fichier source
	data, err := utils.ReadFile(file.Path)
	if err != nil {
		return fmt.Errorf("erreur lors de la lecture: %w", err)
	}

	// Compresser les donn√©es
	compressedData, err := m.compressor.Compress(data)
	if err != nil {
		return fmt.Errorf("erreur lors de la compression: %w", err)
	}

	// Chiffrer les donn√©es compress√©es
	encryptedData, err := m.encryptor.Encrypt(compressedData)
	if err != nil {
		return fmt.Errorf("erreur lors du chiffrement: %w", err)
	}

	// Sauvegarder dans le stockage
	storageKey := fmt.Sprintf("data/%s/%s", backupID, file.GetStorageKey())
	if err := m.saveToStorage(storageKey, encryptedData); err != nil {
		return fmt.Errorf("erreur lors de la sauvegarde: %w", err)
	}

	// Mettre √† jour la cl√© de stockage dans l'entr√©e du fichier
	file.StorageKey = storageKey

	utils.Debug("Fichier sauvegard√©: %s -> %s", file.Path, storageKey)
	return nil
}

// calculateCompressedSize calcule la taille compress√©e totale
func (m *Manager) calculateCompressedSize(added, modified []index.FileEntry) int64 {
	// TODO: Impl√©menter le calcul de la taille compress√©e
	return 0
}

// calculateEncryptedSize calcule la taille chiffr√©e totale
func (m *Manager) calculateEncryptedSize(added, modified []index.FileEntry) int64 {
	// TODO: Impl√©menter le calcul de la taille chiffr√©e
	return 0
}

// deleteBackupFiles supprime les fichiers de donn√©es d'une sauvegarde
func (m *Manager) deleteBackupFiles(backupIndex *index.BackupIndex) error {
	utils.Info("Suppression des fichiers de donn√©es pour: %s", backupIndex.BackupID)

	for _, file := range backupIndex.Files {
		if file.StorageKey != "" {
			if err := m.s3Client.DeleteObject(file.StorageKey); err != nil {
				utils.Warn("Impossible de supprimer le fichier %s: %v", file.StorageKey, err)
			} else {
				utils.Debug("Fichier supprim√©: %s", file.StorageKey)
			}
		}
	}

	return nil
}

// deleteBackupIndex supprime l'index d'une sauvegarde
func (m *Manager) deleteBackupIndex(backupID string) error {
	utils.Info("Suppression de l'index pour: %s", backupID)

	indexKey := fmt.Sprintf("indexes/%s.json", backupID)
	if err := m.s3Client.DeleteObject(indexKey); err != nil {
		return fmt.Errorf("erreur lors de la suppression de l'index: %w", err)
	}

	utils.Debug("Index supprim√©: %s", indexKey)
	return nil
}

// saveToStorage sauvegarde des donn√©es dans le stockage
func (m *Manager) saveToStorage(key string, data []byte) error {
	return m.s3Client.Upload(key, data)
}
